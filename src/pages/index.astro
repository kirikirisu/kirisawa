---
import BaseLayout from "../layouts/BaseLayout.astro";
import LinkBord from "../components/LinkBord.astro";
---

<BaseLayout>
  <main id="game-field" class="container">
    <section class="introduction">
      <div class="me">
        <h1 id="name">Kohei Kirisawa</h1>
        <ul id="profile">
          <li><p>株式会社PR TIMES</p></li>
          <li><p>フロントエンドエンジニア</p></li>
          <li><p>目玉焼きには塩胡椒を振っています。</p></li>
        </ul>
      </div>
      <div id="avatar" class="avatar">
        <img width="190" height="190" src="/kirisawak.png" />
      </div>
    </section>
    <section class="link-bord-union">
      <LinkBord
        class="link-bord"
        siteName="Twitter"
        userId="@kiririLee"
        siteUrl="https://twitter.com/kiririLee"
      />
      <LinkBord
        class="link-bord"
        siteName="GitHub"
        userId="kirikirisu"
        siteUrl="https://github.com/kirikirisu"
      />
      <LinkBord
        class="link-bord"
        siteName="エンジニアブログ"
        userId="kirisawa"
        siteUrl="https://developers.prtimes.jp/author/kirisawakouhei/"
      />
      <LinkBord
        class="link-bord"
        siteName="Qiita"
        userId="kiririri"
        siteUrl="https://qiita.com/kiririri"
      />
    </section>
    <button
      style={{ height: "100px", width: "100px", backgroundColor: "cyan" }}
      id="start-button">start</button
    >
  </main>
</BaseLayout>

<script>
  type Brick = {
    top: number;
    left: number;
    height: number;
    width: number;
  };
  const utils = {
    appearBrick: (targetElement: Element, gameFiled: GameField): Brick => {
      const rect = targetElement.getBoundingClientRect();
      const { ctx, topOffset, leftOffset } = gameFiled;

      const top = rect.top - topOffset;
      const left = rect.left - leftOffset;
      const height = rect.height;
      const width = rect.width;

      ctx.beginPath();
      ctx.rect(left, top, rect.width, rect.height);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
      ctx.closePath();

      return { top, left, height, width };
    },
  };

  const startButton = document.getElementById("start-button");
  startButton?.addEventListener("click", () => {
    console.log("start!");
    const gf = expandGameField();
    if (!gf?.ctx) {
      console.error("context not found");
      return;
    }
    const brickList = deployMultiBrick(gf);

    const keyDownHandler = (e: KeyboardEvent) => {
      if (e.key === "Right" || e.key === "ArrowRight") {
        rightPressed = true;
      } else if (e.key === "Left" || e.key === "ArrowLeft") {
        leftPressed = true;
      }
    };

    const keyUpHandler = (e: KeyboardEvent) => {
      if (e.key === "Right" || e.key === "ArrowRight") {
        rightPressed = false;
      } else if (e.key === "Left" || e.key === "ArrowLeft") {
        leftPressed = false;
      }
    };

    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    const { ctx, height, width } = gf;
    let x = width / 2;
    let y = height - 30;
    let dx = 2;
    let dy = -2;

    const ballRadius = 10;
    const paddleHeight = 10;
    const paddleWidth = 75;
    let paddleX = (width - paddleWidth) / 2;

    let rightPressed = false;
    let leftPressed = false;

    const draw = () => {
      ctx.clearRect(0, 0, width, height);

      // draw ball
      ctx.beginPath();
      ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = "red";
      ctx.fill();
      ctx.closePath();

      // draw paddle
      ctx.beginPath();
      ctx.rect(paddleX, height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
      ctx.closePath();

      // ball
      if (x + dx > width - ballRadius || x + dx < ballRadius) dx = -dx;
      if (y + dy < ballRadius) {
        dy = -dy;
      } else if (y + dy > height - ballRadius) {
        alert("GAME OVER");
        document.location.reload();
        clearInterval(interval);
      }

      x += dx;
      y += dy;

      // paddle
      if (rightPressed) {
        paddleX = Math.min(paddleX + 7, width - paddleWidth);
      } else if (leftPressed) {
        paddleX = Math.max(paddleX - 7, 0);
      }

      if (rightPressed) {
        paddleX += 7;
      } else if (leftPressed) {
        paddleX -= 7;
      }
    };

    const interval = setInterval(draw, 10);
  });

  // Prepare the canvas to be gamefiled
  const expandGameField = (): GameField | undefined => {
    const LANE_SPACE = 250;

    const root = document.getElementById("game-field") as HTMLElement;
    const rect = root.getBoundingClientRect();

    const gameField = document.createElement("canvas") as HTMLCanvasElement;
    const ctx = gameField.getContext("2d");

    const height = rect.height + LANE_SPACE;
    const width = rect.width;

    gameField.height = height;
    gameField.width = width;

    const topOffset = rect.top;
    const leftOffset = rect.left;
    gameField.style.position = "absolute";
    gameField.style.top = topOffset + "px";
    gameField.style.left = leftOffset + "px";

    if (!ctx) return;
    // ctx.fillStyle = "red";
    // ctx?.fillRect(0, 0, rect.width, rect.height);

    root.appendChild(gameField);
    return { ctx, topOffset, leftOffset, height, width };
  };

  type GameField = {
    ctx: CanvasRenderingContext2D;
    topOffset: number;
    leftOffset: number;
    height: number;
    width: number;
  };

  const deployMultiBrick = (gameField: GameField): Brick[] => {
    const { appearBrick } = utils;
    const brickList: Brick[] = [];

    const name = document.getElementById("name") as HTMLHeadElement;
    const profile = document.getElementById("profile") as HTMLUListElement;
    const avatar = document.getElementById("avatar") as HTMLDivElement;
    const linkBordList = document.getElementsByClassName(
      "link-bord"
    ) as HTMLCollection;

    const targetList = [...linkBordList, name, profile, avatar];
    targetList.forEach((target) => {
      const appearedBrick = appearBrick(target, gameField);
      brickList.push(appearedBrick);
    });

    return brickList;
  };
</script>

<style>
  body {
  }
  .container {
    width: 600px;
    margin: 30px auto;
    padding: 0 15px;
  }

  h1 {
    color: sienna;
    font-size: 28px;
    font-weight: bold;
    margin-bottom: 15px;
  }

  .introduction {
    display: flex;
    margin-bottom: 50px;
  }

  .me {
    margin-right: 50px;
  }

  .avatar {
    width: 190px;
    height: 190px;
  }

  img {
    object-fit: cover;
    border-radius: 3%;
  }

  .link-bord-union {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
    gap: 10px;
  }

  .link-bord {
    height: 170px;
  }

  @media (max-width: 480px) {
    .container {
      width: 100vw;
    }

    .introduction {
      display: flex;
      flex-direction: column;
    }

    .me {
      margin-bottom: 30px;
    }
  }
</style>
